#include <iostream>
#include <vector>
#include <string>
using namespace std;


int main()
{
    vector<int> v;

    v.reserve(10);


    cout << v.size() << endl;
	return 0;
}



/*

  - 벡터는 [] 연산자를 제공한다. 
    컴파일러마다 다르지만 visual studio는 인덱스의 경계 바깥에 접근하면 런타임 에러가 난다.

  - [] 이외에도 at() front() end() 메서드로 접근이 가능하다. 

  - at() 함수는 경계 검사를 한다. 

  - 벡터의 모든 접근 시간은 상수 시간(개빠름)

  - for(auto& item : 컨테이너) -> 컨테이너의 내용을 바꿀거면 & 참조해야함. 안바꿀거면 그냥 뽑아도됨

  - 벡터의 [] 연산자는 참조형을 리턴하기 때문에 대입 구문에서 lvalue로 이용이 가능하다. 
    만약 const vector 타입으로 구현되어 있으면 대입 이용은 불가능.(당연한 소리)

  - 벡터를 정적 배열로 이용할거면 vector<type> v(100)  이런식으로 크기를 박아버림. 동적은 그냥 (100)을 빼면 된다. 사실 정적으로 쓸 이유가 없다. 벡터의 장점은 동적이니까 

  - 벡터의 초기화는     vector<int> v(5, 100);  이런식으로 할 수 있다. 크기가 5이고 초기화는 100으로 하는 vector
    따로 설정해주지 않으면 int 는 0 실수형은 0.0 , 포인터는 nullptr 

  - 힙에 생성할 때     auto ret = make_unique<vector<int>>(5, 10); 이런식으로 생성도 당연히 가능 ret->at(3) 이런식으로 접근이 가능하다.

  - 함수 파라미터로 전달할때는 복사 오버헤드 피해야 한다.

  - assign() 이 메서드는 기존에 활용한 벡터의 요소들을 전부 삭제하고 새롭게 사용하는 것이다.

  - swap() 도 있음

  - 벡터는 연산자 오버로딩이 구현되어 있음 == , != , >= 등등 그래서 비교가 가능하다. 

  - 객체가 같은지의 판단은 저장된 개수가 같고, 각 개별항목을 순차적으로 비교 했을 때 같아야 같은 것으로 판단한다.
  
  - ++i , i++ 은 다르다. 후위 증가는 새로운 객체를 리턴해야 되지만 , 전위 증가는 참조를 리턴하기 때문이다.

  - const_iterator  const한 객체를 iterator로 돌때나 , 비 const 객체를 cbegin() , cend()로 호출하게 되면 const_iterator를 받게 되서 수정할 수 없다. 

  - for 문 돌때도 const 타입 iterator를 들이댈 수 있다. for (const auto& strVec : v)

  - 반복자를 사용하는 세가지 이유
  1. 반복자는 임의의 위치에 항목이나 항목의 나열을 삽입, 삭제할 수 있다.
  2. 반복자는 stl 알고리즘 함수를 사용할 수 있다. 
  3. 벡터는 그렇지 않지만 list , map , set은 인덱스보다 반복자가 더 빠르다.

  - pop_back() 함수는 끝부분을 빼버린다. 삭제되는 항목을 리턴하지 않기 때문에 만약 필요하다면 back() 함수로 미리 받아놔야 한다. 

  - insert()로 임의의 위치에 삽입을 할 수 있다. 

  - push_back이랑 insert는 lvalue , rvalue 를 받을 수 있는 오버로딩이 존재한다. 

  - 모든 항목을 삭제할 때는 clear() , 부분을 삭제하는 거면 erase()

  - erase() 는 항목 하나를 삭제하는 것과 , 반복자로 지정된 범위를 삭제하는 것이 있다. 
    만약에 특정 조건을 삭제하는 것일 때는 전체항목을 돌때 속도는 이차 함수다(개느림), 이동 삭제 패턴을 사용하면 선형 시간으로 훨씬 오버헤드가 적다. 

  - 이동 시맨틱. 내가 만약 클래스를 초기화 하고 그걸 벡터로 관리한다고 가정 했을 때 , v.push_back(move(내가정의한 클래스)); 이렇게 이동 시맨틱으로 하면 
    복제 오버헤드 줄어든다. 아니면 v.push_back(클래스생성자) 이렇게 넣어도 된다. 

  - 벡터의 메모리 할당 방식 : 벡터는 삽입할 때 자동으로 메모리를 할당한다. 메모리 재할당이 필요해지면 오버헤드다. 그리고 기존 iterator가 무효화 된다. 
  그래서 재할당을 제어하거나 재할당 상태를 알려주는 interface를 알 필요가 있다. 

  - size()는 저장된 항목의 개수 , capacity()는 메모리 재할당 없이 저장할 수 있는 최대 항목 개수이다. 내가 메모리 할당없이 저장 할 수 있는 개수를 알고 싶으면 capacity() - size()를 하면 된다. 

  - 저장 용량을 미리 확보하려면 reserve()를 사용하면 된다. reserve()를 한다고 해서 size()가 커지는게 아니라는 걸 이해해야 한다. 

  - 저장 용량을 또 미리 확보 하는 방법은 벡터의 생성자 이용 혹은 resize()를 이용하는 방법이 있다. 이건 size()를 키우는 것이다. 


*/